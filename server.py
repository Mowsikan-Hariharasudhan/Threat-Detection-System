from flask import Flask, request, jsonify
from flask_socketio import SocketIO, emit
from flask_cors import CORS
from flask_mail import Mail, Message
import time
import threading
import random
import uuid
from datetime import datetime
import os
from db import db_manager

# ML models removed as per user request
HAS_ML_MODELS = False

app = Flask(__name__)

# --- Email Configuration ---
app.config['MAIL_SERVER'] = 'smtp.gmail.com'
app.config['MAIL_PORT'] = 587
app.config['MAIL_USE_TLS'] = True
app.config['MAIL_USERNAME'] = os.environ.get('EMAIL_USER')
app.config['MAIL_PASSWORD'] = os.environ.get('EMAIL_PASS')
app.config['MAIL_DEFAULT_SENDER'] = os.environ.get('EMAIL_USER')

mail = Mail(app)

# Allow all origins for CORS
CORS(app, resources={r"/*": {"origins": "*", "allow_headers": "*", "expose_headers": "*"}})

# Initialize SocketIO with permissive CORS
socketio = SocketIO(app, 
                   cors_allowed_origins="*", 
                   logger=True, 
                   engineio_logger=True,
                   async_mode='eventlet')

# Fallback in-memory storage if DB is not connected
THREAT_HISTORY = []

def send_threat_notification(threat):
    """Sends an email notification for a detected threat."""
    try:
        # Check if credentials are set
        if not app.config['MAIL_USERNAME'] or not app.config['MAIL_PASSWORD']:
            print("Email credentials not set. Skipping notification.")
            return

        with app.app_context():
            subject = f"ðŸš¨ Security Alert: {threat['scenario']['type']} Detected"
            
            # Recipient: For now, sending to the admin (same as sender or configured separately)
            recipient = os.environ.get('SECURITY_TEAM_EMAIL', app.config['MAIL_USERNAME'])
            
            msg = Message(subject, recipients=[recipient])
            
            # HTML Body
            msg.html = f"""
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; border: 1px solid #e2e8f0; border-radius: 8px; overflow: hidden;">
                <div style="background-color: #0f172a; padding: 20px; text-align: center;">
                    <h1 style="color: #ffffff; margin: 0;">Security Alert</h1>
                </div>
                <div style="padding: 24px; background-color: #ffffff;">
                    <div style="background-color: #fee2e2; border-left: 4px solid #ef4444; padding: 12px; margin-bottom: 20px;">
                        <strong style="color: #991b1b;">Risk Level: {threat['risk_level']}</strong>
                    </div>
                    
                    <h2 style="color: #1e293b; margin-top: 0;">{threat['scenario']['type']}</h2>
                    <p style="color: #475569;">{threat['scenario']['description']}</p>
                    
                    <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                        <tr>
                            <td style="padding: 8px; border-bottom: 1px solid #e2e8f0; color: #64748b;">Timestamp</td>
                            <td style="padding: 8px; border-bottom: 1px solid #e2e8f0; font-weight: bold; color: #0f172a;">{threat['timestamp']}</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border-bottom: 1px solid #e2e8f0; color: #64748b;">Risk Score</td>
                            <td style="padding: 8px; border-bottom: 1px solid #e2e8f0; font-weight: bold; color: #0f172a;">{threat['risk_score']}/100</td>
                        </tr>
                        <tr>
                            <td style="padding: 8px; border-bottom: 1px solid #e2e8f0; color: #64748b;">Confidence</td>
                            <td style="padding: 8px; border-bottom: 1px solid #e2e8f0; font-weight: bold; color: #0f172a;">{threat['confidence']}%</td>
                        </tr>
                    </table>
                    
                    <h3 style="color: #1e293b;">Recommended Actions:</h3>
                    <ul style="color: #475569;">
                        {''.join(f'<li>{action}</li>' for action in threat.get('recommendations', []))}
                    </ul>
                    
                    <div style="margin-top: 24px; text-align: center;">
                        <a href="https://threat-detection-system-frontend.vercel.app" style="background-color: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; font-weight: bold;">View System Dashboard</a>
                    </div>
                </div>
                <div style="background-color: #f8fafc; padding: 16px; text-align: center; color: #94a3b8; font-size: 12px;">
                    Generated by CyberGuard AI â€¢ {datetime.now().year}
                </div>
            </div>
            """
            
            mail.send(msg)
            print(f"ðŸ“§ Threat notification sent to {recipient}")

    except Exception as e:
        print(f"Failed to send email: {e}")

def generate_mock_threat(type="network"):
    threat_id = str(uuid.uuid4())
    
    if type == "login_bruteforce":
        return {
            "id": threat_id,
            "timestamp": datetime.now().isoformat(),
            "risk_score": random.randint(85, 99),
            "risk_level": "CRITICAL",
            "risk_factors": {
                "frequency": 5,
                "behavioral": 5,
                "geographic": 3,
                "temporal": 4
            },
            "scenario": {
                "type": "Brute Force Authentication",
                "description": "Multiple failed login attempts detected from single IP within short timeframe.",
                "severity": "Critical"
            },
            "recommendations": [
                "Lock account immediately",
                "Block source IP address",
                "Enable 2FA for user",
                "Review auth logs for other affected accounts",
                "Reset password"
            ],
            "confidence": 98.5
        }
    
    # Random threat generation
    risk_score = random.randint(40, 95)
    level = "LOW"
    if risk_score > 60: level = "MEDIUM"
    if risk_score > 80: level = "HIGH"
    if risk_score > 90: level = "CRITICAL"
    
    scenarios = [
        {
            "type": "Suspicious Network Activity",
            "description": "Anomalous outbound traffic pattern detected matching C2 communication profile.",
            "severity": level
        },
        {
            "type": "Malware Signature Detected",
            "description": "File system scan identified potential ransomware signature in temp directory.",
            "severity": level
        },
        {
            "type": "Phishing Attempt",
            "description": "Incoming email contains suspicious links and urgent language characteristic of phishing.",
            "severity": level
        }
    ]
    
    scenario = random.choice(scenarios)
    
    return {
        "id": threat_id,
        "timestamp": datetime.now().isoformat(),
        "risk_score": risk_score,
        "risk_level": level,
        "risk_factors": {
            "network_anomaly": random.randint(1, 5),
            "malware_signature": random.randint(0, 5),
            "heuristic": random.randint(2, 4)
        },
        "scenario": scenario,
        "recommendations": [
            "Isolate affected host",
            "Analyze packet capture",
            "Scan for malware",
            "Reset user credentials",
            "Update firewall rules"
        ][:random.randint(3, 5)],
        "confidence": round(random.uniform(80, 99), 1)
    }

@app.route('/api/demo-login', methods=['POST'])
def demo_login():
    data = request.json
    attempts = data.get('attempts', 0)
    
    if attempts >= 3:
        threat = generate_mock_threat("login_bruteforce")
        
        # Save to DB if connected, else memory
        if db_manager.is_connected:
            db_manager.insert_threat(threat)
        else:
            THREAT_HISTORY.append(threat)
            
        socketio.emit('new_threat', threat)
        
        # Send Email Notification Async
        # We start a new thread to avoid blocking the response
        email_thread = threading.Thread(target=send_threat_notification, args=(threat,))
        email_thread.start()
        
        return jsonify({"status": "threat_detected", "threat": threat})
    
    return jsonify({"status": "failed", "message": "Invalid credentials"})

@app.route('/api/threats', methods=['GET'])
def get_threats():
    if db_manager.is_connected:
        threats = db_manager.get_recent_threats()
        return jsonify(threats)
    return jsonify(THREAT_HISTORY)

@app.route('/api/stats', methods=['GET'])
def get_stats():
    if db_manager.is_connected:
        stats = db_manager.get_threat_stats()
        return jsonify(stats)
    
    # Fallback for in-memory
    total = len(THREAT_HISTORY)
    critical = sum(1 for t in THREAT_HISTORY if t.get('risk_level') == 'CRITICAL')
    return jsonify({'total': total, 'critical': critical})

@app.route('/api/threat-explanation/<threat_id>', methods=['GET'])
def get_threat_explanation(threat_id):
    # Try DB first
    if db_manager.is_connected:
        # Note: In a real app we'd query by ID, but for now we'll just search the recent list 
        # or implement a get_by_id in db.py if needed. 
        # For simplicity in this demo, we might skip specific ID fetch from DB 
        # unless we add that method.
        pass

    threat = next((t for t in THREAT_HISTORY if t['id'] == threat_id), None)
    if threat:
        return jsonify(threat)
    return jsonify({"error": "Threat not found"}), 404



if __name__ == '__main__':
    print("Starting Cybersecurity Threat Detection Server...")
    # Background threat generator disabled as per user request
    # t = threading.Thread(target=background_threat_generator)
    # t.daemon = True
    # t.start()
    
    socketio.run(app, host='0.0.0.0', port=5000, debug=True, use_reloader=False)
